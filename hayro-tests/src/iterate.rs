use hayro::Pdf;
use memchr::memmem::Finder;
use rayon::prelude::*;
use std::collections::HashSet;
use std::env;
use std::fs;
use std::path::PathBuf;
use std::sync::atomic::AtomicU32;
use std::sync::{Arc, LazyLock};
use walkdir::WalkDir;

#[rustfmt::skip]
static IGNORE_LIST: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
    let list = &[
        // Password-protected
        "0000300", "0004569", "0006766", "0007159", "0008404", "0010697", "0015407", "0021311", 
        "0024617", "0023496", "0025709", "0023957", "0032605", "0017669", "0030672", "0018317", 
        "0029028", "0029047", "0031090", "0029063", "0023040", "0044179", "0050583", "0039233", 
        "0046280", "0040420", "0040495", "0046836", "0041847", "0068926", "0072306", "0064042", 
        "0076921", "0064846", "0077568", "0057222", "0065390", "0056150", "0074700", "0094987", 
        "0060563", "0095373", "0061317", "0097349", "0098054", "0090237", "0093278",
        
        // Works in other PDF viewers
        "0092523",
        
        // Returns invalid encryption, but is just password-protected
        "0090598",
        
        // Broken PDF, maybe fixable
        "0000399", "0003304", "0016072", "0017877", "0027069", "0027591", 
        
        // HTML
        "0000819", "0000920", "0001589", "0002064", "0002187", "0002244", "0002372", "0002554",
        "0002638", "0002966", "0003269", "0003892", "0003927", "0003983", "0004537", "0004889",
        "0004997", "0006169", "0006207", "0006339", "0006844", "0008443", "0008674", "0008978",
        "0009309", "0009464", "0009706", "0010117", "0010216", "0010902", "0011171", "0011398", 
        "0012117", "0012730", "0013178", "0013425", "0013587", "0013721", "0014006", "0014380", 
        "0015073", "0015740", "0016112", "0016335", "0016620", "0027676", "0027711", "0027958", 
        "0030263", "0028017", "0026590", "0022312", "0026641", "0029294", "0026660", "0018066", 
        "0026686", "0028171", "0026831", "0030557", "0021599", "0022634", "0018346", "0028367", 
        "0029696", "0018417", "0021747", "0021857", "0022077", "0030922", "0031948", "0027492", 
        "0024274", "0019413", "0032055", "0019706", "0032086", "0032096", "0019762", "0019782", 
        "0031403", "0032231", "0019637", "0020498", "0032430", "0021142", "0032755", "0031769", 
        "0021090", "0020881", "0032878", "0025439", "0033538", "0029331", "0050052", "0075253", 
        "0075458", "0050450", "0075523", "0075630", "0075707", "0050727", "0087974", "0050855", 
        "0075986", "0076041", "0051088", "0088328", "0051108", "0088448", "0088718", "0088826", 
        "0088853", "0051643", "0076758", "0089218", "0089238", "0089294", "0037595", "0089675", 
        "0077283", "0052531", "0089898", "0081362", "0081402", "0077573", "0077604", "0052820", 
        "0077657", "0052861", "0081550", "0052884", "0038186", "0034574", "0081848", "0038487", 
        "0081859", "0053199", "0090535", "0078071", "0090562", "0038577", "0053337", "0090665", 
        "0078284", "0078311", "0082176", "0090884", "0053607", "0090933", "0078541", "0078542", 
        "0084528", "0084541", "0078602", "0053777", "0053879", "0078753", "0078755", "0039130", 
        "0082515", "0091318", "0084813", "0084877", "0084881", "0079084", "0082753", "0091673", 
        "0054213", "0035862", "0054337", "0079300", "0056253", "0054418", "0097062", "0079508", 
        "0039890", "0039924", "0097168", "0056620", "0094597", "0097198", "0036212", "0079658", 
        "0092299", "0092315", "0036244", "0094662", "0063064", "0097345", "0063104", "0040178", 
        "0054946", "0054950", "0056900", "0063211", "0083594", "0097565", "0063326", "0083725", 
        "0036568", "0036735", "0055276", "0034173", "0084041", "0034274", "0092825", "0084128", 
        "0057536", "0055492", "0084335", "0057682", "0055623", "0098155", "0098163", "0096206", 
        "0086745", "0064016", "0057764", "0080677", "0057790", "0064061", "0098261", "0064113", 
        "0096434", "0087008", "0098455", "0041194", "0068854", "0043770", "0056130", "0059524", 
        "0064559", "0096873", "0068987", "0046921", "0046948", "0058383", "0058387", "0099230", 
        "0043051", "0069042", "0059717", "0042354", "0042364", "0064762", "0069149", "0044079", 
        "0064816", "0043188", "0042470", "0042477", "0042528", "0099584", "0060004", "0099004", 
        "0093448", "0060036", "0058876", "0099153", "0044439", "0060197", "0047591", "0060984", 
        "0093673", "0061035", "0093734", "0059178", "0099995", "0047814", "0044714", "0065708", 
        "0065410", "0061746", "0069874", "0065424", "0060634", "0070017", "0061391", "0065855", 
        "0061451", "0070167", "0060852", "0061595", "0067686", "0061596", "0065590", "0045106", 
        "0066085", "0045135", "0067765", "0045179", "0045193", "0070399", "0062328", "0073464", 
        "0067810", "0062277", "0062443", "0045345", "0072112", "0073659", "0072143", "0068090", 
        "0068093", "0070694", "0048906", "0048719", "0068143", "0071335", "0068158", "0048981", 
        "0049869", "0049880", "0073840", "0049908", "0072328", "0074032", "0046231", "0046484", 
        "0045984", "0071619", "0071064", "0074293", "0046650", "0074639", "0074674", "0046465", 
        "0074991", "0066518", "0074778", "0072979", "0042158",
        
        // Invalid PDFs
        "0002229", "0002883", "0002897", "0003147", "0004099", "0004791", "0004853", "0005482", 
        "0005637", "0006036", "0006262", "0007559", "0009290", "0009944", "0010114", "0010472",
        "0010802", "0010950", "0011041", "0011758", "0011989", "0012684", "0013051", "0013338", 
        "0013822", "0014523", "0016181", "0016883", "0081682", "0075407", "0081725", "0088689", 
        "0089967", "0083689", "0052682", "0084504", "0053435", "0062911", "0091339", "0091355", 
        "0086037", "0054825", "0098919", "0093019", "0093027", "0086857", "0087172", "0087262", 
        "0080818", "0087439", "0065520", "0093433", "0065522", "0093257", "0043130", "0047495", 
        "0072494", "0034857", "0036040", "0047775", "0044846", "0058154", "0061197", "0037349", 
        "0074494", "0067147", "0074576", "0071823", "0066440",
    ];
    
    let mut set = HashSet::new();
    set.extend(list);
    
    set
});

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() != 2 {
        eprintln!("Usage: {} <folder>", args[0]);
        std::process::exit(1);
    }

    let folder = &args[1];

    let mut pdf_paths: Vec<PathBuf> = WalkDir::new(folder)
        .into_iter()
        .map(|entry| entry.unwrap())
        .filter(|entry| entry.file_type().is_file())
        .map(|entry| entry.path().to_path_buf())
        .filter(|path| {
            path.extension()
                .unwrap_or_default()
                .eq_ignore_ascii_case("pdf")
        })
        .collect();

    pdf_paths.sort();

    println!("Found {} PDF files", pdf_paths.len());

    let count = AtomicU32::new(0);

    pdf_paths.par_iter().for_each(|path| {
        let data = Arc::new(fs::read(path).unwrap());
        let name = path.file_stem().unwrap().to_str().unwrap().to_string();

        if IGNORE_LIST.contains(&name.as_str()) {
            return;
        }

        match Pdf::new(data.clone()) {
            Ok(_) => {}
            Err(e) => {
                let html_finder = Finder::new("html");
                let script_finder = Finder::new("<script");
                let reason = if html_finder.find(data.as_slice()).is_some()
                    || script_finder.find(data.as_slice()).is_some()
                {
                    "html".to_string()
                } else {
                    format!("{:?}", e)
                };
                println!("{} - {}", name, reason);
            }
        }

        let count = count.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
        if count.is_multiple_of(2000) {
            // println!("Processed {} PDFs", count);
        }
    });
}
